{
  "metadata": {
    "title": "Longest Common Substring - Complete Guide",
    "duration": "8-10 minutes",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "total_scenes": 8,
    "theme": "dark",
    "primary_color": "#1e88e5",
    "secondary_color": "#43a047",
    "background_color": "#121212",
    "text_color": "#ffffff",
    "accent_color": "#ff7043"
  },
  "scenes": [
    {
      "scene_id": 1,
      "timestamp": "00:00-01:00",
      "title": "Introduction",
      "visual_description": "Title slide with problem name and brief overview",
      "script": "Welcome to our comprehensive guide on the Longest Common Substring problem. This is a classic dynamic programming problem that appears frequently in coding interviews and has practical applications in text analysis, bioinformatics, and string processing. Today, we'll explore what this problem is, analyze its nuances, solve it step by step, and implement an efficient solution using dynamic programming. Let's dive in!",
      "html": "<!DOCTYPE html>\n<html>\n<head>\n<style>\nbody {\n  background: #121212;\n  color: #fff;\n  font-family: Arial, sans-serif;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100vh;\n  margin: 0;\n}\n.container {\n  text-align: center;\n  padding: 40px;\n}\n.title {\n  font-size: 48px;\n  color: #1e88e5;\n  margin-bottom: 20px;\n}\n.subtitle {\n  font-size: 24px;\n  color: #43a047;\n  margin-bottom: 30px;\n}\n.description {\n  font-size: 18px;\n  line-height: 1.6;\n  max-width: 800px;\n}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <h1 class=\"title\">Longest Common Substring</h1>\n  <h2 class=\"subtitle\">Dynamic Programming Solution</h2>\n  <p class=\"description\">A comprehensive guide to understanding and implementing the longest common substring algorithm</p>\n</div>\n</body>\n</html>"
    },
    {
      "scene_id": 2,
      "timestamp": "01:00-02:30",
      "title": "Problem Definition",
      "visual_description": "Problem statement with example strings highlighted",
      "script": "The Longest Common Substring problem asks us to find the longest contiguous sequence of characters that appears in two or more strings. For example, given strings 'ABABC' and 'BABCA', the longest common substring is 'BABC' with length 4. Notice that this is different from the longest common subsequence, as we need contiguous characters here. This problem has real-world applications in plagiarism detection, genetic sequence analysis, and information retrieval systems where identifying common text patterns is crucial.",
      "html": "<!DOCTYPE html>\n<html>\n<head>\n<style>\nbody {\n  background: #121212;\n  color: #fff;\n  font-family: Arial, sans-serif;\n  padding: 40px;\n  margin: 0;\n}\n.container {\n  max-width: 1000px;\n  margin: 0 auto;\n}\n.title {\n  font-size: 36px;\n  color: #1e88e5;\n  margin-bottom: 30px;\n  text-align: center;\n}\n.problem {\n  background: #1e1e1e;\n  padding: 30px;\n  border-radius: 8px;\n  margin-bottom: 30px;\n}\n.example {\n  background: #2e2e2e;\n  padding: 20px;\n  border-radius: 8px;\n  margin: 20px 0;\n}\n.string {\n  font-family: monospace;\n  font-size: 20px;\n  color: #43a047;\n  margin: 10px 0;\n}\n.highlight {\n  background: #ff7043;\n  color: #000;\n  padding: 2px 4px;\n  border-radius: 3px;\n}\n.result {\n  margin-top: 20px;\n  color: #1e88e5;\n  font-weight: bold;\n}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <h1 class=\"title\">Problem Definition</h1>\n  <div class=\"problem\">\n    <p>Find the longest contiguous sequence of characters that appears in two strings.</p>\n    <div class=\"example\">\n      <div class=\"string\">String 1: AB<span class=\"highlight\">ABC</span></div>\n      <div class=\"string\">String 2: B<span class=\"highlight\">ABC</span>A</div>\n      <div class=\"result\">Longest Common Substring: \"ABC\" (length = 3)</div>\n    </div>\n  </div>\n</div>\n</body>\n</html>"
    },
    {
      "scene_id": 3,
      "timestamp": "02:30-03:30",
      "title": "Approach Overview",
      "visual_description": "Comparison of brute force vs dynamic programming approaches",
      "script": "When facing this problem, several approaches come to mind. The naive brute force method would check all possible substrings of both input strings, comparing each pair to find common matches. This approach has O(n³) time complexity, making it impractical for longer strings. Instead, we'll use dynamic programming to solve it in O(n×m) time, where n and m are the lengths of our input strings. The key insight is to build a table that tracks common substring lengths at each position, allowing us to efficiently identify the longest shared substring without redundant comparisons.",
      "html": "<!DOCTYPE html>\n<html>\n<head>\n<style>\nbody {\n  background: #121212;\n  color: #fff;\n  font-family: Arial, sans-serif;\n  padding: 40px;\n  margin: 0;\n}\n.container {\n  max-width: 1000px;\n  margin: 0 auto;\n}\n.title {\n  font-size: 36px;\n  color: #1e88e5;\n  margin-bottom: 30px;\n  text-align: center;\n}\n.approach {\n  background: #1e1e1e;\n  padding: 30px;\n  border-radius: 8px;\n  margin-bottom: 20px;\n}\n.complexity {\n  background: #2e2e2e;\n  padding: 20px;\n  border-radius: 8px;\n  margin: 20px 0;\n}\n.good {\n  color: #43a047;\n}\n.bad {\n  color: #ff7043;\n}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <h1 class=\"title\">Solution Approaches</h1>\n  <div class=\"approach\">\n    <h3 class=\"bad\">Brute Force: O(n³)</h3>\n    <p>Check all possible substrings - inefficient for large inputs</p>\n  </div>\n  <div class=\"approach\">\n    <h3 class=\"good\">Dynamic Programming: O(n×m)</h3>\n    <p>Build a table to track common substring lengths efficiently</p>\n    <div class=\"complexity\">\n      <strong>Key Insight:</strong> dp[i][j] = length of common substring ending at position i,j\n    </div>\n  </div>\n</div>\n</body>\n</html>"
    },
    {
      "scene_id": 4,
      "timestamp": "03:30-05:00",
      "title": "DP Table Construction",
      "visual_description": "Step-by-step DP table filling animation with highlighted cells",
      "script": "Let's build our dynamic programming table step by step. We create a 2D array where dp[i][j] represents the length of the common substring ending at position i in the first string and j in the second string. The key recurrence relation is: when characters match (str1[i] equals str2[j]), we extend the previous diagonal value by 1, setting dp[i][j] = dp[i-1][j-1] + 1. If characters don't match, we reset to 0 since we're looking for continuous matches. As we fill the table, we keep track of the maximum value and its position, which will allow us to extract the longest common substring at the end of the process.",
      "html": "<!DOCTYPE html>\n<html>\n<head>\n<style>\nbody {\n  background: #121212;\n  color: #fff;\n  font-family: Arial, sans-serif;\n  padding: 40px;\n  margin: 0;\n}\n.container {\n  max-width: 1200px;\n  margin: 0 auto;\n}\n.title {\n  font-size: 36px;\n  color: #1e88e5;\n  margin-bottom: 30px;\n  text-align: center;\n}\n.table-container {\n  background: #1e1e1e;\n  padding: 30px;\n  border-radius: 8px;\n}\n.dp-table {\n  border-collapse: collapse;\n  margin: 20px auto;\n}\n.dp-table td, .dp-table th {\n  border: 1px solid #444;\n  padding: 12px;\n  text-align: center;\n  font-family: monospace;\n  font-size: 16px;\n}\n.dp-table th {\n  background: #2e2e2e;\n  color: #1e88e5;\n}\n.match {\n  background: #43a047 !important;\n  color: #000;\n}\n.no-match {\n  background: #1e1e1e;\n}\n.rule {\n  margin: 20px 0;\n  padding: 15px;\n  background: #2e2e2e;\n  border-radius: 8px;\n}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <h1 class=\"title\">DP Table Construction</h1>\n  <div class=\"table-container\">\n    <div class=\"rule\">Rule: If str1[i] == str2[j], then dp[i][j] = dp[i-1][j-1] + 1, else dp[i][j] = 0</div>\n    <table class=\"dp-table\">\n      <tr><th></th><th></th><th>A</th><th>B</th><th>A</th><th>B</th><th>C</th></tr>\n      <tr><th></th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>\n      <tr><th>B</th><td>0</td><td class=\"no-match\">0</td><td class=\"match\">1</td><td class=\"no-match\">0</td><td class=\"match\">1</td><td class=\"no-match\">0</td></tr>\n      <tr><th>A</th><td>0</td><td class=\"match\">1</td><td class=\"no-match\">0</td><td class=\"match\">1</td><td class=\"no-match\">0</td><td class=\"no-match\">0</td></tr>\n      <tr><th>B</th><td>0</td><td class=\"no-match\">0</td><td class=\"match\">1</td><td class=\"no-match\">0</td><td class=\"match\">1</td><td class=\"no-match\">0</td></tr>\n      <tr><th>C</th><td>0</td><td class=\"no-match\">0</td><td class=\"no-match\">0</td><td class=\"no-match\">0</td><td class=\"no-match\">0</td><td class=\"match\">1</td></tr>\n      <tr><th>A</th><td>0</td><td class=\"match\">1</td><td class=\"no-match\">0</td><td class=\"match\">1</td><td class=\"no-match\">0</td><td class=\"no-match\">0</td></tr>\n    </table>\n  </div>\n</div>\n</body>\n</html>"
    },
    {
      "scene_id": 5,
      "timestamp": "05:00-06:30",
      "title": "Code Implementation",
      "visual_description": "Clean code implementation with syntax highlighting",
      "script": "Now, let's implement our solution in JavaScript. We first initialize a DP table with zeros - this is a 2D array of size (m+1) × (n+1) where m and n are the lengths of our input strings. We keep track of two variables: maxLength to store the length of the longest common substring found so far, and endIndex to record where this substring ends in the first string. As we iterate through both strings character by character, when we find a match, we update our DP table based on the previous diagonal value plus one. We continuously update maxLength and endIndex whenever we find a longer common substring. Finally, we extract and return the actual substring using the recorded position and length. This implementation has a time complexity of O(n×m) for the nested loops and space complexity of O(n×m) for the DP table.",
      "html": "<!DOCTYPE html>\n<html>\n<head>\n<style>\nbody {\n  background: #121212;\n  color: #fff;\n  font-family: Arial, sans-serif;\n  padding: 40px;\n  margin: 0;\n}\n.container {\n  max-width: 1200px;\n  margin: 0 auto;\n}\n.title {\n  font-size: 36px;\n  color: #1e88e5;\n  margin-bottom: 30px;\n  text-align: center;\n}\n.code-container {\n  background: #1e1e1e;\n  padding: 30px;\n  border-radius: 8px;\n  overflow-x: auto;\n}\n.code {\n  font-family: 'Courier New', monospace;\n  font-size: 14px;\n  line-height: 1.6;\n}\n.keyword {\n  color: #ff7043;\n}\n.string {\n  color: #43a047;\n}\n.comment {\n  color: #888;\n}\n.function {\n  color: #1e88e5;\n}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <h1 class=\"title\">Implementation</h1>\n  <div class=\"code-container\">\n    <pre class=\"code\"><span class=\"comment\">/**\n * Finds the longest common substring between two strings\n * @param {string} str1 - First input string\n * @param {string} str2 - Second input string\n * @returns {string} - The longest common substring\n */</span>\n<span class=\"keyword\">function</span> <span class=\"function\">longestCommonSubstring</span>(str1, str2) {\n    <span class=\"comment\">// Get the lengths of input strings</span>\n    <span class=\"keyword\">const</span> m = str1.length;\n    <span class=\"keyword\">const</span> n = str2.length;\n    \n    <span class=\"comment\">// Initialize DP table with zeros</span>\n    <span class=\"keyword\">const</span> dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));\n    \n    <span class=\"comment\">// Track maximum length and ending position</span>\n    <span class=\"keyword\">let</span> maxLength = 0;\n    <span class=\"keyword\">let</span> endIndex = 0;\n    \n    <span class=\"comment\">// Fill the DP table</span>\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = 1; i <= m; i++) {\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = 1; j <= n; j++) {\n            <span class=\"comment\">// If characters match</span>\n            <span class=\"keyword\">if</span> (str1[i - 1] === str2[j - 1]) {\n                <span class=\"comment\">// Extend previous match length by 1</span>\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n                \n                <span class=\"comment\">// Update maximum if needed</span>\n                <span class=\"keyword\">if</span> (dp[i][j] > maxLength) {\n                    maxLength = dp[i][j];\n                    endIndex = i;\n                }\n            }\n            <span class=\"comment\">// If characters don't match, dp[i][j] remains 0</span>\n        }\n    }\n    \n    <span class=\"comment\">// Extract the longest common substring</span>\n    <span class=\"keyword\">return</span> str1.substring(endIndex - maxLength, endIndex);\n}</pre>\n  </div>\n</div>\n</body>\n</html>"
    },
    {
      "scene_id": 6,
      "timestamp": "06:30-07:30",
      "title": "Example Walkthrough",
      "visual_description": "Live example with strings 'ABABC' and 'BABCA' showing table filling",
      "script": "Let's trace through our solution with an example using the strings 'ABABC' and 'BABCA'. We'll fill the DP table cell by cell, highlighting when characters match and how values propagate. Starting with empty cells initialized to zero, we compare each character pair. When B from the first string matches B from the second, we set dp[1][1] to 1. Similarly, for A-A matches, we set values to 1. The interesting part happens when we have consecutive matches - when we reach dp[3][3], we set it to 2 because the previous characters also matched. This pattern continues, and we eventually find the longest common substring 'BABC' with length 4, ending at position 4 in the first string. This process elegantly captures all possible substrings while focusing on the longest match.",
      "html": "<!DOCTYPE html>\n<html>\n<head>\n<style>\nbody {\n  background: #121212;\n  color: #fff;\n  font-family: Arial, sans-serif;\n  padding: 40px;\n  margin: 0;\n}\n.container {\n  max-width: 1200px;\n  margin: 0 auto;\n}\n.title {\n  font-size: 36px;\n  color: #1e88e5;\n  margin-bottom: 30px;\n  text-align: center;\n}\n.example {\n  background: #1e1e1e;\n  padding: 30px;\n  border-radius: 8px;\n}\n.strings {\n  display: flex;\n  justify-content: space-around;\n  margin: 20px 0;\n}\n.string {\n  font-family: monospace;\n  font-size: 18px;\n  color: #43a047;\n}\n.result {\n  background: #2e2e2e;\n  padding: 20px;\n  border-radius: 8px;\n  margin: 20px 0;\n  text-align: center;\n}\n.highlight {\n  background: #ff7043;\n  color: #000;\n  padding: 2px 4px;\n  border-radius: 3px;\n}\n.step-details {\n  margin: 20px 0;\n  line-height: 1.6;\n}\n.final-result {\n  font-size: 20px;\n  font-weight: bold;\n  margin-top: 30px;\n  color: #1e88e5;\n}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <h1 class=\"title\">Example Walkthrough</h1>\n  <div class=\"example\">\n    <div class=\"strings\">\n      <div>String 1: <span class=\"string\">A<span class=\"highlight\">BABC</span></span></div>\n      <div>String 2: <span class=\"string\"><span class=\"highlight\">BABC</span>A</span></div>\n    </div>\n    <div class=\"step-details\">\n      <p>1. Initialize DP table with all zeros</p>\n      <p>2. Compare each character pair:</p>\n      <ul>\n        <li>When B matches B: Set dp[1][1] = 1</li> \n        <li>When A matches A: Set dp[2][2] = dp[1][1] + 1 = 2</li>\n        <li>When B matches B: Set dp[3][3] = dp[2][2] + 1 = 3</li>\n        <li>When C matches C: Set dp[4][4] = dp[3][3] + 1 = 4</li>\n      </ul>\n      <p>3. Track maximum length = 4 at position (4,4)</p>\n    </div>\n    <div class=\"final-result\">\n      Longest Common Substring: <span class=\"highlight\">BABC</span> (length = 4)\n    </div>\n  </div>\n</div>\n</body>\n</html>"
    },
    {
      "scene_id": 7,
      "timestamp": "07:30-08:30",
      "title": "Optimization",
      "visual_description": "Space-optimized version showing rolling array technique",
      "script": "While our implementation works well, we can optimize its space complexity from O(n×m) to O(min(n,m)). The key observation is that when filling the DP table, each cell depends only on the previous row's diagonal value. This means we don't need to store the entire table - we can use a rolling array technique where we only keep track of the previous row to compute the current row. This optimization is particularly valuable when dealing with very long strings where memory usage becomes a concern. However, there's a trade-off: if we need to reconstruct the actual substring, we might need additional tracking information or revert to the original approach. In practice, the choice between space efficiency and ease of implementation depends on your specific constraints.",
      "html": "<!DOCTYPE html>\n<html>\n<head>\n<style>\nbody {\n  background: #121212;\n  color: #fff;\n  font-family: Arial, sans-serif;\n  padding: 40px;\n  margin: 0;\n}\n.container {\n  max-width: 1000px;\n  margin: 0 auto;\n}\n.title {\n  font-size: 36px;\n  color: #1e88e5;\n  margin-bottom: 30px;\n  text-align: center;\n}\n.optimization {\n  background: #1e1e1e;\n  padding: 30px;\n  border-radius: 8px;\n  margin-bottom: 20px;\n}\n.comparison {\n  display: flex;\n  justify-content: space-between;\n  gap: 20px;\n}\n.before, .after {\n  background: #2e2e2e;\n  padding: 20px;\n  border-radius: 8px;\n  flex: 1;\n}\n.improvement {\n  color: #43a047;\n  font-weight: bold;\n}\n.note {\n  margin-top: 20px;\n  font-style: italic;\n}\n.code-snippet {\n  background: #333;\n  padding: 15px;\n  border-radius: 5px;\n  margin-top: 15px;\n  font-family: monospace;\n  line-height: 1.4;\n  font-size: 14px;\n  overflow-x: auto;\n}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <h1 class=\"title\">Space Optimization</h1>\n  <div class=\"optimization\">\n    <div class=\"comparison\">\n      <div class=\"before\">\n        <h3>Original Implementation</h3>\n        <p>Space: O(n × m)</p>\n        <p>Keep full DP table</p>\n        <div class=\"code-snippet\">const dp = Array(m+1).fill().map(() => Array(n+1).fill(0));</div>\n      </div>\n      <div class=\"after\">\n        <h3>Optimized Implementation</h3>\n        <p>Space: <span class=\"improvement\">O(min(n,m))</span></p>\n        <p>Use rolling array</p>\n        <div class=\"code-snippet\">let prev = Array(n+1).fill(0);<br>let curr = Array(n+1).fill(0);</div>\n      </div>\n    </div>\n    <p class=\"note\">Since we only need the previous row to compute the current row, we can reduce space complexity significantly for large inputs while maintaining the same time complexity.</p>\n  </div>\n</div>\n</body>\n</html>"
    },
    {
      "scene_id": 8,
      "timestamp": "08:30-09:00",
      "title": "Conclusion",
      "visual_description": "Summary slide with key points and complexity analysis",
      "script": "To summarize, the Longest Common Substring problem is elegantly solved using dynamic programming with O(n×m) time complexity. The key insights we've covered include: creating a DP table where each cell represents the length of the common substring ending at those positions, filling the table based on character matches, tracking the maximum length and its ending position, and finally extracting the result. We've also seen how to optimize the space complexity when needed. This problem-solving technique is fundamental and appears in many string processing algorithms, from text comparison to bioinformatics. The same approach can be extended to find common substrings among multiple strings or with additional constraints. Thank you for exploring this classic algorithm with us!",
      "html": "<!DOCTYPE html>\n<html>\n<head>\n<style>\nbody {\n  background: #121212;\n  color: #fff;\n  font-family: Arial, sans-serif;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  min-height: 100vh;\n  margin: 0;\n  padding: 20px;\n}\n.container {\n  text-align: center;\n  padding: 40px;\n  max-width: 1000px;\n}\n.title {\n  font-size: 42px;\n  color: #1e88e5;\n  margin-bottom: 30px;\n}\n.summary {\n  background: #1e1e1e;\n  padding: 30px;\n  border-radius: 8px;\n  margin-bottom: 30px;\n}\n.points-container {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-around;\n  gap: 20px;\n}\n.point {\n  background: #2e2e2e;\n  padding: 15px;\n  border-radius: 8px;\n  margin: 10px 0;\n  font-size: 16px;\n  flex-basis: 45%;\n  text-align: left;\n}\n.complexity {\n  color: #43a047;\n  font-weight: bold;\n}\n.applications {\n  margin-top: 20px;\n  background: #2e2e2e;\n  padding: 15px;\n  border-radius: 8px;\n}\n.thanks {\n  font-size: 24px;\n  color: #ff7043;\n  margin-top: 30px;\n}\n</style>\n</head>\n<body>\n<div class=\"container\">\n  <h1 class=\"title\">Key Takeaways</h1>\n  <div class=\"summary\">\n    <div class=\"points-container\">\n      <div class=\"point\">✓ <span class=\"complexity\">O(n×m) time complexity</span> using Dynamic Programming</div>\n      <div class=\"point\">✓ DP state: length of common substring ending at positions i,j</div>\n      <div class=\"point\">✓ Space can be optimized to <span class=\"complexity\">O(min(n,m))</span></div>\n      <div class=\"point\">✓ Can be extended to multiple strings</div>\n    </div>\n    <div class=\"applications\">\n      <h3>Real-world Applications</h3>\n      <p>Plagiarism detection, DNA sequence analysis, data compression, and text processing</p>\n    </div>\n  </div>\n  <p class=\"thanks\">Thanks for exploring this algorithm with us!</p>\n</div>\n</body>\n</html>"
    }
  ]
}
